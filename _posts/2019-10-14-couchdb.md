---
layout: post
title: "CoucbDB: challenges of building offline-first mobile application"
---
Contents:
1. [Introduction](#intro)
1. [Database structure: paradigm shift](#db-structure)
1. [Authentication & Authorization](#auth)
1. [Offline & Challenges of synchronization](#offline)
1. [What is more?](#more)

{:#intro}
## 1. Introduction
As the title says, this article is going to be all about challenges I have encountered building an offline-first mobile application with CouchDB and my solutions to them. My solutions/approaches are in no way perfect or the only way. That's why I wrote this article - I want you to share your suggestions in the comments section. 

I decided to write this post as a story. A story of 3-4 months of sitting on my couch. By the way, do you remember CouchDB saying to you "Relax"? Personally, I don't really remember relaxing. Anyway, CouchDB does its job!

So, let's do it.
{:#db-structure}
## 2. Database structure: paradigm shift
Before starting the project, I already had a well-defined database schema in SQL and at first it was kind of awkward trying to squeeze an SQL schema into NoSQL. For example, am I going to have 30 CouchDB dbs if I have 30 tables?

Not really, as it turns out. It made sense to apply the following steps for each type of relationship in my SQL db:

**One-to-one.** They both go into one CouchDB db. For example, if you have `seller-account` relationship, you would have a db named `seller` and have `account` data as its property:

`seller` table:

id | name     | address                | ... 
---|----------|------------------------|-----
123|Ali Carter|Sevens Street, 7, 100077|...|

`account` table:

id | seller_id | card              | expiry | ... 
---|-----------|-------------------|--------|-----
342|123        |8888 8888 8888 8888|10/17   |...

The above two tables get merged into one db:
```javascript
{
  "id": "123",
  "name": "Ali Carter",
  "address": "Sevens Street, 7, 100077",
  "account": { // <- nested here
    "card": "8888 8888 8888 8888",
    "expiry": "10/17"
  }
}
```

**One-to-many.** This relationship is not much different from one-to-one, except instead of object you have an array as a property. Let's change the previous example and assume one seller has many accounts. Then, we would achieve the following:

```javascript
{
  "id": "123",
  "name": "Ali Carter",
  "address": "Sevens Street, 7, 100077",
  "accounts": [{ // <- nested here
    "card": "8888 8888 8888 8888",
    "expiry": "10/17"
  }, {
    "card": "7777 7777 7777 7777",
    "expiry": "10/18"
  }]
}
```

**Many-to-many.** In this scenario, we have three tables forming the relation and they get mapped into 2 CouchDB dbs. As an example, let's take Stackoverflow's badges. In Stackoverflow, one user can have many badges and one badge can belong to many users. So, we have the following many-to-many structure:

`user` table:

username | name      | reputation | ... 
---------|-----------|------------|-----
user123  |Ali Carter |78120       |...
user456  |Joey Jey   |45454       |...

`badge` table:

id | title  | ... 
---|--------|-----
1  | Gold   |...
2  | Silver |...
3  | Bronze |...

`user_badge` table

id | username | badge_id | date     | ... 
---|----------|----------|----------|----
1  |user123   |1         |2019/10/10|...
2  |user123   |2         |2019/10/12|...
3  |user456   |4         |2019/10/13|...
4  |user456   |2         |2019/10/14|...

The above three tables get translated into the following two dbs:

`user` db

```javascript
{
  "username": "user123",
  "name": "Ali Carter",
  "reputation": 78120,
  "badges": [
    1,
    2
  ]
}
```

`badge` db


```javascript
{
  "id": "1",
  "title": "Gold"
  // you could have users array here, but that depends on your application logic
}
```
The next came the concerns of data integrity. With SQL data integrity is achieved naturally through table schemas: there is a well-defined set of constraints on what you can insert. On the other hand, a CouchDB db is by default loose and absolutely anything can be inserted as a document. 

CouchDB validates data using design documents. Specifically validation guards. And, interestingly these documents are stored among other documents in your db. Such design approach is very clever. To understand why it is clever, we first need to understand CouchDB's replication feature (a killer feature).

CouchDB is designed with scaling in mind. You can have several CouchDB instances spread across many servers constantly in sync with each other. If you decide to add one more instance, all you have to do is to create the dbs in the new instance and activate replications. All the existing data flow in and since design documents are treated the same way as other documents they also get replicated automatically.

In short, a validation guard is a function which either completes (meaning document is valid) or throws an error, in which case insertion fails. Let's create a validation guard for one of the examples above. Our typical document:

`user` db

```javascript
{
  "_id": "myidhere123sgdgmsmkncnsmsms",
  "_rev": "1-73bdn73udnxnnnx787779nxnx",
  "username": "user123",
  "name": "Ali Carter",
  "reputation": 78120,
  "badges": [
    1,
    2
  ]
}
```

```
{
  "_id": "_design/_validation_guard",
  "language": "javascript",
  "validate_doc_update": "..."
}
```
`validate_doc_update` function:
```
function(newDoc, oldDoc, userCtx, secObj) {
    function require(field, message) {
        message = message || "Document must have a " + field;
        if (!newDoc[field]) throw({forbidden : message});
    };
    
    function validateNumber(field, message) {
        message = message || "doc." + field + " must be number";
        if(typeof newDoc[field] !== "number") throw({forbidden : message});
    };
    
    function validateArray(field, message) {
        message = message || "doc." + field + " must be array";
        if(!Array.isArray(newDoc[field])) throw({forbidden : message});
    };
    
    require('username');
    require('name');
    validateNumber('reputation');
    require('badges');
    
    if (oldDoc) { // validate all updates
        if (oldDoc.username !== newDoc.username) {
            throw({forbidden: 'doc.username can not be changed.'});
        }
    }
}
```

Now, CouchDB calls our validation function every time a document is created or updated. The function checks if a) `username` and `name` are set, b) `reputation` is a number, c) `badges` is an array. Additionally, it also makes sure that `username` is never changed once a document is created.

One last thing. I have realized that it is a bad idea to think SQL-way when reasoning about NOSQL db. Forget the SQL concepts (tables, columns, foreign keys) and its best practices. Read CouchDB's [https://docs.couchdb.org/en/stable/index.html](documentation) and start new.

{:#auth}
## 3. Authentication & Authorization


{:#offline}
## 4. Offline & Challenges of synchronization


{:#more}
## 5. What is more?
